### Ben Lehrburger
### COSC 076 PA5

# Description

This program implements two problem solvers for propositional logic satisfiability problems: GSAT and walkSAT. GSAT is a more elementary version of walkSAT and solves problems more efficiently by eliminating redundancy and minimizing random error. The problem we're trying to solve is Sudoku at varying complexities. The algorithms assign truth values to Sudoku boards, defined in conjunctive normal form, until all of their constraints are satisfied and the puzzle is solved.

The first algorithm, GSAT, builds a model by randomly assigning a truth value to each variable in the problem. If that assignment satisfies all of the conditions laid out by the problem in conjunctive normal form, then we consider the problem solved. Otherwise, we need to revise our model. We can either do this (a) randomly to try and avoid getting caught in a local minimum or (b) informed by how many clauses some new assignment would satisfy. The random method chooses a random number between 1 and 0 and compares it to an arbitrary threshold; if it is greater than that threshold, then we pick a variable at random and flip its truth value. Otherwise, if the value is not greater than the threshold, we proceed to the informed revision option. In this case, the program takes each variable and scores how many clauses would be satisfied if the variable's truth value were to be flipped. The variable with the highest satisfaction score is subsequently chosen and flipped. At this point, we then check to see if the new model satisfies the problem's clauses. We continue doing so until we reach complete satisfaction and, thus, the solution.

The second algorithm, walkSAT, is slightly more informed than GSAT. It follows the same procedure with a couple modifications. Instead of choosing variable to flip at random, walkSAT only chooses variables that are part of unsatisfied clauses, so as to limit the chances of flipping an already correct assignment. So, for the first revision option, if the random value is greater than the threshold, the program randomly selects an unsatisfied clause and then randomly selects a variable to flip from it. For the second revision option, if the algorithm is less than the threshold, the algorithm randomly selects an unsatisfied clause and then selects from that clause the variable whose flipped truth value satisfies the most clauses in a new model. In this way, walkSAT is more computationally efficient than GSAT.

# Evaluation

As noted above, GSAT ran significantly slower than walkSAT. I attribute this to walkSAT's ability to only flip values that are are part of unsatisfied clauses, as opposed to flipping values at random. As a result, GSAT was only able to solve the 'one cell' problem before I got tired of waiting for it to finish executing.

walkSAT, on the other hand, was much more deft and computationally powerful. I chose to make my threshold 0.7 such that the program would have roughly a 1/3 chance of choosing a random unsatisfied variable and a 2/3 chance of choosing an informed unsatisfied variable. At first, I was storing all of my data in lists, each of which cost O(n) to use. This made testing extremely difficult. I was convinced my algorithm wasn't computing properly. When I changed all of the data structures to sets, however, the runtime complexity of operations using these structures was reduced to O(1). After doing so, the program took about two minutes to complete puzzle 1 and an extra 30 seconds to complete puzzle 2. Considering that this is much faster than myself or any human I know could solve these puzzles, I would consider the algorithm a success.
